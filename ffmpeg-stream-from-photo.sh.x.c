#if 0
	shc Version 3.9.6, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f /usr/local/ffmpeg-stream-from-photo/ffmpeg-stream-from-photo.sh -o /usr/local/ffmpeg-stream-from-photo/ffmpeg-stream-from-photo 
#endif

static  char data [] = 
#define      pswd_z	256
#define      pswd	((&data[33]))
	"\167\245\043\101\236\144\251\311\277\207\226\141\360\010\054\314"
	"\130\203\054\074\162\032\317\224\317\133\375\021\147\203\347\337"
	"\051\172\054\371\042\134\013\351\174\251\024\313\153\174\213\203"
	"\262\371\006\155\335\062\143\146\233\065\252\103\365\153\271\137"
	"\346\345\130\010\101\144\361\276\015\006\211\171\202\025\374\064"
	"\017\002\242\355\065\006\124\321\073\377\025\061\153\317\220\121"
	"\264\351\131\366\115\113\264\133\121\076\325\323\124\321\010\144"
	"\324\253\121\012\261\246\334\355\245\361\036\020\300\257\142\165"
	"\230\273\154\346\006\040\102\130\137\027\053\264\351\064\030\276"
	"\337\152\311\221\020\245\176\266\226\235\307\127\114\051\314\344"
	"\345\070\313\354\131\015\104\271\045\160\155\017\244\206\316\204"
	"\360\227\026\001\074\225\270\323\062\177\052\177\251\367\144\216"
	"\060\057\172\212\075\277\103\143\057\261\162\324\070\100\131\051"
	"\327\157\052\024\004\343\347\067\142\022\266\013\011\032\232\071"
	"\112\025\304\207\324\010\352\004\271\135\330\362\236\061\033\166"
	"\241\106\212\246\051\162\335\213\204\224\227\215\256\062\307\370"
	"\107\214\200\034\224\153\040\116\311\371\100\147\052\133\336\314"
	"\241\151\162\313\333\120\127\137\344\357\355\222\041\265\213\151"
	"\101\013\040\307\157\312\221\057\121\047\220\102\060\275\016\210"
	"\101\072\305\264\124\224\110\044\360\106\065\127\311\035\067\362"
	"\050\130\272\227\042\114\307\164\164\127\266\244\025\304\055\127"
	"\377\362\013\123\207\124\170"
#define      tst1_z	22
#define      tst1	((&data[346]))
	"\317\144\313\174\336\242\302\174\241\120\005\120\023\142\216\010"
	"\355\360\045\003\216\062\234\035\076\007\127\363\137"
#define      msg1_z	65
#define      msg1	((&data[381]))
	"\136\122\366\322\252\254\167\300\161\064\157\072\151\251\274\173"
	"\130\346\362\256\112\116\160\114\225\352\031\353\365\220\076\311"
	"\017\374\022\154\057\210\065\055\041\343\150\012\340\361\052\301"
	"\334\073\351\163\260\250\161\162\162\023\215\175\305\244\121\272"
	"\036\121\266\104\023\237\366\347\062\122\244\027\160\227\043\304"
	"\036\170"
#define      shll_z	10
#define      shll	((&data[455]))
	"\353\067\215\376\115\102\070\341\135\356\215"
#define      lsto_z	1
#define      lsto	((&data[465]))
	"\333"
#define      chk1_z	22
#define      chk1	((&data[470]))
	"\316\341\066\120\307\057\073\235\041\316\062\223\006\110\370\372"
	"\064\234\136\127\332\133\272\346\030\034\077\211\107"
#define      date_z	1
#define      date	((&data[495]))
	"\155"
#define      msg2_z	19
#define      msg2	((&data[500]))
	"\055\014\327\305\123\063\007\160\171\070\165\136\354\374\152\005"
	"\307\146\027\332\300\104\024\057"
#define      rlax_z	1
#define      rlax	((&data[520]))
	"\340"
#define      text_z	608
#define      text	((&data[594]))
	"\304\341\062\173\117\002\045\036\343\134\156\043\345\266\065\031"
	"\252\277\015\020\355\031\347\262\111\203\226\360\134\021\253\040"
	"\363\336\234\103\340\301\141\304\036\317\350\003\205\035\035\060"
	"\334\052\100\312\104\050\174\216\253\022\177\007\044\052\050\027"
	"\011\304\132\352\206\273\256\245\213\316\173\364\052\116\000\127"
	"\105\141\255\076\241\277\035\205\362\173\320\137\054\323\061\161"
	"\113\230\077\101\250\210\222\335\120\324\334\002\277\244\227\242"
	"\330\072\157\250\043\266\100\164\312\313\161\031\165\153\003\346"
	"\270\046\374\377\041\245\116\361\315\346\155\137\300\053\162\334"
	"\025\227\247\100\020\166\126\102\151\057\232\125\005\320\143\034"
	"\072\333\215\172\026\340\055\362\266\113\066\035\057\103\020\162"
	"\065\207\115\244\142\023\042\340\366\254\305\211\303\374\246\343"
	"\303\217\053\021\112\320\362\105\065\227\357\242\060\300\170\105"
	"\334\315\125\114\135\153\154\077\227\321\163\210\137\256\307\102"
	"\033\111\204\266\201\345\124\346\230\025\172\030\253\066\004\203"
	"\200\373\025\102\326\001\100\314\374\237\335\106\371\252\251\055"
	"\053\223\305\016\336\361\275\175\130\365\062\330\332\332\220\372"
	"\337\321\267\314\371\315\145\136\166\163\365\005\350\233\104\200"
	"\021\161\265\253\223\300\047\021\377\331\055\220\167\105\313\346"
	"\354\020\133\121\344\337\333\246\042\163\244\317\112\010\267\231"
	"\155\342\344\324\005\361\152\145\243\242\166\271\055\243\011\107"
	"\230\032\101\242\153\165\355\017\305\012\027\306\211\322\327\061"
	"\143\106\150\132\352\106\242\351\071\071\354\365\366\051\212\235"
	"\023\042\037\325\000\330\256\022\155\250\261\170\023\316\256\005"
	"\076\260\110\355\310\256\035\014\160\173\273\320\325\243\352\141"
	"\033\260\031\017\132\103\341\317\147\360\304\375\275\234\173\335"
	"\162\037\052\136\305\201\260\140\154\102\121\363\372\064\147\327"
	"\347\207\161\352\356\220\224\170\301\314\040\321\257\316\172\222"
	"\262\015\172\203\122\054\317\112\163\321\051\270\113\224\166\004"
	"\041\052\061\033\160\105\103\230\211\142\340\042\040\163\233\256"
	"\247\131\112\235\253\376\107\157\055\004\270\357\225\022\176\032"
	"\137\216\061\066\157\210\037\116\023\063\305\244\316\347\372\261"
	"\261\075\147\350\214\042\241\152\124\042\340\325\016\226\116\362"
	"\012\172\377\262\321\041\035\255\304\053\114\334\266\207\371\234"
	"\071\067\207\032\130\346\267\254\171\134\336\170\211\160\354\153"
	"\217\160\244\214\300\205\071\036\345\361\230\267\010\142\071\171"
	"\105\021\121\075\254\313\311\333\327\006\236\165\252\342\002\277"
	"\300\042\211\060\264\202\000\107\236\064\057\144\265\274\166\037"
	"\264\023\076\273\136\302\267\222\157\140\173\174\057\226\211\336"
	"\167\230\305\255\021\353\337\175\010\012\357\014\005\006\030\054"
	"\246\224\204\241\037\276\230\323\102\202\070\311\256\025\024\204"
	"\371\176\004\233\362\103\116\205\372\370\031\175\152\006\215\221"
	"\305\062\232\220\035\326\234\227\253\226\250\021\264\305\101\221"
	"\360\202\133\065\252\330\303\125\353\102\135\017\155\206\047\166"
	"\113\201\140\322\075\017\167\311\246\040\332\132\345\033\354\326"
	"\236\110\013\110\040\317\236\013\022\374\033\177\203\102\366\316"
	"\304\126\241\001\146\031\312\014\071\245\147\037\301\124\365\137"
	"\234\001\247\274\321\106\310\343\102\343\142\305\045\130\224\352"
	"\257\065\353\026\116\266\042\210\133\212\247\034\336\235\173\173"
	"\237\043\070\160\152\000\123\254"
#define      tst2_z	19
#define      tst2	((&data[1316]))
	"\012\017\007\217\171\267\217\104\332\174\235\264\111\206\017\342"
	"\330\165\213\251\113\037\364\276"
#define      inlo_z	3
#define      inlo	((&data[1337]))
	"\106\021\343"
#define      opts_z	1
#define      opts	((&data[1340]))
	"\040"
#define      xecc_z	15
#define      xecc	((&data[1344]))
	"\273\017\140\364\310\052\365\371\036\065\047\364\047\241\127\265"
	"\311\002\131\213"
#define      chk2_z	19
#define      chk2	((&data[1365]))
	"\023\150\031\024\144\256\311\135\303\353\232\267\275\064\320\124"
	"\024\174\323\173\067\121\131\273\306\370"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
