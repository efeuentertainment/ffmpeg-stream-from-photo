#if 0
	shc Version 3.9.6, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f /usr/local/ffmpeg-stream-from-photo/ffmpeg-stream-from-photo.sh -o /usr/local/ffmpeg-stream-from-photo/ffmpeg-stream-from-photo 
#endif

static  char data [] = 
#define      rlax_z	1
#define      rlax	((&data[0]))
	"\104"
#define      opts_z	1
#define      opts	((&data[1]))
	"\212"
#define      tst1_z	22
#define      tst1	((&data[6]))
	"\372\100\331\333\014\120\135\315\040\161\340\076\021\147\310\207"
	"\332\217\045\365\064\106\215\027\126\261\050\233\036\047"
#define      text_z	609
#define      text	((&data[51]))
	"\022\204\137\140\115\263\366\076\043\206\246\331\117\374\211\362"
	"\267\001\271\065\125\153\314\134\376\003\154\070\073\017\315\000"
	"\214\102\155\043\067\164\145\367\314\235\221\123\326\140\112\373"
	"\364\244\127\042\334\206\377\044\056\274\053\314\030\234\227\166"
	"\270\145\132\032\307\373\137\336\153\150\065\310\006\244\156\347"
	"\064\333\064\017\365\173\142\023\240\136\066\302\065\203\111\255"
	"\125\206\132\354\345\250\067\035\224\353\322\120\347\173\340\050"
	"\352\103\154\332\161\101\074\144\242\150\353\301\350\336\230\210"
	"\114\247\154\025\077\112\230\206\021\362\302\032\221\072\077\050"
	"\244\121\323\300\007\236\121\051\321\364\370\162\356\175\260\376"
	"\265\116\023\354\277\271\212\110\261\075\176\122\362\164\104\273"
	"\213\317\241\305\145\304\330\277\333\377\227\311\120\220\071\273"
	"\063\226\014\343\204\022\346\004\223\342\156\125\344\102\124\126"
	"\037\370\262\101\331\216\243\265\162\237\321\202\034\147\063\340"
	"\337\337\320\273\246\327\210\106\067\172\033\371\127\100\000\153"
	"\360\157\226\014\151\375\274\256\312\014\235\302\141\346\072\237"
	"\146\241\015\312\201\150\262\151\102\316\051\116\053\016\067\274"
	"\055\217\241\334\301\114\145\044\120\267\116\227\077\126\054\221"
	"\027\140\041\137\210\241\076\154\041\156\203\163\333\011\152\317"
	"\277\031\152\120\206\255\147\025\172\114\052\320\153\116\315\045"
	"\225\376\226\227\161\115\071\201\154\230\063\121\017\355\063\215"
	"\155\367\032\155\244\032\066\245\346\150\163\137\264\126\360\043"
	"\203\052\213\120\252\247\116\372\352\112\241\323\023\024\233\272"
	"\052\132\332\173\146\172\255\074\267\270\032\057\027\164\107\255"
	"\077\010\254\244\267\052\365\121\313\111\320\321\137\072\127\243"
	"\017\146\074\221\105\036\056\036\331\154\132\104\242\246\253\365"
	"\151\336\370\341\113\327\267\377\365\015\000\301\235\071\171\302"
	"\107\270\122\144\155\076\212\202\040\134\305\251\120\312\052\056"
	"\101\154\054\102\316\354\313\321\330\221\323\203\274\051\045\316"
	"\302\371\023\036\152\100\336\264\143\124\075\071\024\264\236\304"
	"\005\277\137\035\233\061\357\366\013\155\150\061\131\143\270\163"
	"\077\255\020\140\225\151\012\355\377\347\105\236\216\376\174\367"
	"\001\045\056\065\235\125\203\161\272\366\213\075\143\107\315\011"
	"\010\041\077\275\217\202\153\376\111\052\315\250\161\220\335\371"
	"\067\266\311\040\346\375\315\302\161\320\075\217\135\161\024\132"
	"\101\341\305\026\154\160\071\026\002\235\273\074\337\024\366\015"
	"\072\153\207\042\364\272\060\047\224\231\245\034\117\227\043\332"
	"\137\306\115\320\242\346\166\272\107\353\220\370\165\332\066\050"
	"\000\303\074\160\356\206\203\323\166\004\000\127\131\372\000\212"
	"\243\237\237\314\155\374\372\107\327\043\343\365\112\226\025\107"
	"\250\232\246\011\347\131\000\045\175\206\313\126\325\310\340\307"
	"\200\341\201\356\336\173\065\265\236\030\252\350\257\277\057\130"
	"\131\326\141\100\057\141\145\254\350\061\002\275\372\342\205\172"
	"\304\006\150\242\201\235\127\040\266\002\010\145\301\070\275\033"
	"\016\037\134\076\201\301\352\151\363\354\046\355\317\253\147\223"
	"\262\320\066\063\155\216\124\044\220\134\211\122\225\107\155\244"
	"\146\311\342\347\213\314\120\177\271\167\155\210\043\325\034\325"
	"\245\123\011\023\341\135\067\161\272\300\304\120\010\061\364\156"
	"\373\327\126\207\244\247\007\135\037\164\346"
#define      shll_z	10
#define      shll	((&data[811]))
	"\036\234\355\327\062\256\137\060\352\207"
#define      msg1_z	65
#define      msg1	((&data[836]))
	"\042\002\067\200\071\251\073\371\155\213\001\237\200\160\233\222"
	"\141\257\275\012\376\377\345\250\311\022\213\310\363\354\371\153"
	"\200\042\104\202\110\161\056\012\331\156\153\203\271\371\207\255"
	"\043\120\324\304\230\205\131\325\152\046\345\004\174\006\022\141"
	"\014\316\020\005\341\351\255\353\355\314\300\360\333\135\166\075"
	"\130\306\042\374\156"
#define      date_z	1
#define      date	((&data[906]))
	"\166"
#define      msg2_z	19
#define      msg2	((&data[908]))
	"\347\351\276\213\171\120\002\024\250\022\011\271\050\370\142\310"
	"\335\254\332\042\103\350\326\231"
#define      pswd_z	256
#define      pswd	((&data[986]))
	"\213\022\172\306\014\350\122\015\210\322\176\043\052\105\106\047"
	"\263\160\200\101\016\300\020\366\003\371\315\235\003\246\156\216"
	"\270\351\125\304\321\247\322\131\172\120\175\245\226\303\314\112"
	"\063\114\213\102\015\234\071\331\161\112\200\152\201\175\330\205"
	"\020\254\005\357\144\011\066\252\116\112\254\164\365\222\022\154"
	"\064\100\352\220\037\014\151\220\127\351\373\330\146\323\136\167"
	"\177\143\146\343\154\235\216\273\350\073\057\335\315\102\112\001"
	"\203\064\222\242\101\373\063\230\344\056\161\113\002\317\302\202"
	"\062\051\146\237\306\365\132\256\060\212\214\375\315\326\377\120"
	"\013\221\363\114\214\046\344\161\125\125\274\130\045\177\332\127"
	"\250\101\366\156\066\121\035\146\334\251\143\251\200\143\372\214"
	"\365\355\330\201\024\275\363\152\023\257\302\070\056\235\220\327"
	"\336\207\105\025\331\143\173\265\015\337\137\216\102\131\032\070"
	"\107\363\271\133\261\254\306\304\134\210\375\213\046\216\142\004"
	"\025\250\031\356\013\225\244\031\165\003\247\267\134\301\360\244"
	"\264\251\377\145\126\305\052\263\116\050\076\164\266\241\171\314"
	"\111\223\272\125\051\136\156\236\142\026\126\276\327\106\143\214"
	"\360\143\362\106\051\034\372\167\104\071\354\373\332\146\307\043"
	"\372\202\171\043\340\350\301\102\376\030\001\325\136\145\142\116"
	"\310\124\225\361\160\217\150\021\225\006\256\231\255\035\050\145"
	"\006\175\051\327\044\374\061\236\115\256\104\343\162\020\055\246"
	"\134\271\350\152\125\041\173\352\050\052\203\325\107\253\073\115"
	"\051\144\045\116\141\127\355\256\005\061\222\170"
#define      inlo_z	3
#define      inlo	((&data[1295]))
	"\025\132\373"
#define      tst2_z	19
#define      tst2	((&data[1300]))
	"\010\316\352\043\370\365\121\165\316\033\135\037\201\261\026\170"
	"\174\271\057\250\244"
#define      xecc_z	15
#define      xecc	((&data[1321]))
	"\121\256\314\317\007\017\017\160\147\376\321\376\217\206\153\165"
	"\262\075\047"
#define      chk2_z	19
#define      chk2	((&data[1342]))
	"\104\022\307\151\137\014\213\121\200\015\270\201\155\210\326\336"
	"\070\210\105\266\223\161\032\140"
#define      lsto_z	1
#define      lsto	((&data[1362]))
	"\121"
#define      chk1_z	22
#define      chk1	((&data[1367]))
	"\151\077\277\051\120\047\314\341\152\065\314\351\235\215\041\057"
	"\173\173\151\300\053\045\214\000\054\042\135\136"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
