#if 0
	shc Version 3.9.6, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f /usr/local/ffmpeg-stream-from-photo/ffmpeg-histogram.sh -o /usr/local/ffmpeg-stream-from-photo/ffmpeg-histogram 
#endif

static  char data [] = 
#define      lsto_z	1
#define      lsto	((&data[0]))
	"\166"
#define      tst1_z	22
#define      tst1	((&data[6]))
	"\364\215\137\164\046\351\040\061\146\270\105\212\057\332\241\251"
	"\146\304\140\271\067\310\150\326\160\316\273"
#define      msg1_z	65
#define      msg1	((&data[33]))
	"\363\146\044\002\035\312\307\003\363\245\035\374\337\264\345\053"
	"\051\030\312\343\134\016\247\072\147\301\043\127\032\146\176\304"
	"\064\344\373\363\012\250\335\377\125\150\254\313\325\032\261\163"
	"\217\106\167\336\375\032\346\017\256\010\217\215\034\032\004\362"
	"\122\256\234\010\264\327\236\352\253\114\211\275\017\104\213\227"
	"\263\314\006\156\332"
#define      chk1_z	22
#define      chk1	((&data[115]))
	"\140\373\057\334\176\172\102\267\224\375\213\154\046\367\333\242"
	"\376\245\321\343\254\066\075\316\075\325\041\122\046"
#define      pswd_z	256
#define      pswd	((&data[159]))
	"\053\111\252\311\063\125\026\275\023\045\002\236\275\265\152\303"
	"\044\053\377\370\204\340\133\121\266\066\134\132\325\125\320\127"
	"\376\300\366\100\101\263\301\203\212\331\360\111\317\346\335\124"
	"\021\335\115\226\275\251\350\163\340\105\316\265\233\236\014\231"
	"\137\003\332\240\266\233\044\101\165\024\213\105\372\150\231\014"
	"\106\347\243\003\220\213\166\160\321\105\046\154\343\062\005\102"
	"\066\337\343\354\173\007\056\361\034\271\066\027\042\320\043\150"
	"\267\307\154\107\122\342\270\044\047\336\220\013\021\226\116\107"
	"\166\061\064\362\070\143\343\124\034\031\153\077\351\217\250\241"
	"\126\024\351\251\367\241\315\037\200\136\052\221\364\170\331\153"
	"\251\015\135\342\160\100\066\215\132\242\315\104\062\165\345\210"
	"\212\316\062\201\160\000\241\361\136\313\203\123\104\134\276\356"
	"\152\033\320\333\134\007\151\266\252\066\373\334\254\340\145\066"
	"\257\230\270\040\230\132\022\367\045\225\113\152\362\011\130\134"
	"\045\050\070\202\060\241\071\332\327\064\266\204\025\033\272\305"
	"\263\163\345\114\315\370\103\363\215\216\135\200\230\265\335\276"
	"\336\025\100\016\266\171\350\216\255\236\022\303\272\315\210\156"
	"\101\105\060\221\042\220\215\140\145\257\262\214\265\371\031\340"
	"\102\303\252\166\030\300\064\054\346\066\312\244\354\065\147\020"
	"\173\227\242\236"
#define      date_z	1
#define      date	((&data[450]))
	"\226"
#define      msg2_z	19
#define      msg2	((&data[455]))
	"\032\224\252\063\165\045\160\251\267\367\177\101\351\171\257\230"
	"\363\320\123\131\167\315\052\165\354\367"
#define      shll_z	10
#define      shll	((&data[478]))
	"\341\015\015\022\257\041\061\163\032\212\133"
#define      rlax_z	1
#define      rlax	((&data[488]))
	"\252"
#define      text_z	719
#define      text	((&data[494]))
	"\272\075\323\312\270\346\253\336\005\162\237\270\277\166\212\155"
	"\377\132\156\366\306\130\236\241\323\072\356\276\136\230\002\307"
	"\337\173\220\012\260\022\134\071\175\020\025\376\065\225\041\164"
	"\104\125\103\004\203\324\053\317\010\034\206\275\147\230\072\177"
	"\217\044\070\267\345\317\236\240\034\244\000\161\212\325\136\122"
	"\320\120\362\031\127\307\365\364\027\147\306\066\360\334\171\250"
	"\227\074\272\152\130\353\244\123\060\173\224\363\063\372\275\171"
	"\323\057\047\145\210\173\372\301\237\315\001\036\004\301\205\234"
	"\150\126\144\355\220\204\316\213\147\147\341\007\265\077\077\266"
	"\231\230\231\273\061\150\315\224\000\235\055\020\322\311\014\375"
	"\210\161\053\076\046\202\324\137\335\055\305\367\060\226\102\132"
	"\307\050\314\240\136\144\131\011\037\233\366\324\007\322\132\017"
	"\216\346\232\162\140\203\221\062\266\327\023\070\057\343\134\267"
	"\256\014\126\267\265\222\216\152\354\216\011\360\045\303\354\356"
	"\115\145\341\273\173\026\175\053\153\050\051\161\273\134\137\022"
	"\334\001\343\036\002\064\174\132\132\076\153\307\064\255\102\363"
	"\220\211\147\131\272\226\037\317\114\226\212\054\346\047\316\230"
	"\023\315\047\260\114\225\332\100\255\341\247\004\232\206\021\050"
	"\156\336\032\376\361\125\223\221\200\207\126\170\107\060\165\276"
	"\277\013\353\025\245\333\134\217\202\271\364\263\134\240\016\133"
	"\156\352\003\262\024\116\122\342\364\007\314\023\237\371\203\212"
	"\306\330\273\132\173\367\365\301\237\102\062\121\044\274\221\134"
	"\320\136\146\370\302\130\077\011\376\234\010\063\154\010\054\040"
	"\035\100\211\263\231\156\263\201\065\071\036\123\323\364\316\306"
	"\146\313\074\351\002\363\350\176\353\112\256\363\225\163\144\005"
	"\212\004\370\003\030\036\104\061\244\361\247\257\251\064\055\357"
	"\332\130\072\000\027\157\075\311\174\366\277\216\255\027\160\247"
	"\223\166\044\334\222\015\006\265\203\166\217\346\337\047\107\233"
	"\246\242\160\152\131\243\327\113\074\231\302\335\320\203\337\051"
	"\100\152\103\115\352\112\253\112\115\332\305\156\220\005\071\350"
	"\126\367\020\156\326\207\333\131\250\275\034\371\061\207\125\250"
	"\122\325\236\144\103\106\201\101\334\116\116\064\132\336\262\343"
	"\122\201\044\121\241\123\315\240\141\035\172\034\223\012\372\027"
	"\313\260\004\357\021\227\340\373\177\033\177\371\021\233\211\134"
	"\243\112\057\154\233\251\157\071\034\001\344\145\371\044\260\307"
	"\041\247\161\326\224\051\056\120\265\313\065\265\275\030\112\115"
	"\254\115\037\057\127\103\357\304\012\304\027\026\015\101\207\025"
	"\054\360\312\325\077\327\072\033\354\230\275\143\174\376\037\034"
	"\053\266\371\345\350\173\350\162\342\106\220\343\036\077\047\274"
	"\271\102\363\146\355\343\107\256\276\004\012\012\316\145\271\032"
	"\352\274\261\054\346\117\300\355\001\173\056\015\367\146\061\207"
	"\230\001\351\035\042\117\315\213\071\126\251\064\264\057\324\376"
	"\342\100\256\102\300\020\146\242\262\211\103\174\342\176\153\054"
	"\244\020\153\003\032\272\011\275\054\234\312\041\354\060\131\120"
	"\136\356\207\062\165\312\064\100\101\237\151\376\116\022\317\132"
	"\325\100\276\057\153\155\126\223\235\124\042\174\005\074\020\260"
	"\160\206\235\147\247\000\167\210\230\264\120\146\273\274\040\370"
	"\220\352\260\373\127\007\217\365\134\262\161\142\357\202\022\137"
	"\010\260\307\257\260\077\070\110\363\210\256\256\105\316\247\326"
	"\271\130\321\021\137\141\006\274\023\170\036\002\372\061\142\002"
#define      tst2_z	19
#define      tst2	((&data[1289]))
	"\162\046\331\137\341\273\371\233\366\332\115\066\052\110\271\046"
	"\262\056\127\222\151\352"
#define      chk2_z	19
#define      chk2	((&data[1312]))
	"\211\245\241\304\150\067\105\225\114\076\140\140\306\257\141\326"
	"\342\001\342\113\013\271"
#define      xecc_z	15
#define      xecc	((&data[1335]))
	"\022\013\266\125\341\232\116\001\211\324\235\110\322\361\202\013"
	"\045\141\044"
#define      opts_z	1
#define      opts	((&data[1352]))
	"\354"
#define      inlo_z	3
#define      inlo	((&data[1353]))
	"\130\045\302"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
